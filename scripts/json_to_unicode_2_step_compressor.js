/**
 * ====================================================================
 *         JSON-to-Unicode Two-Stage Compressor Library
 *
 * This script provides a simple, high-level API for compressing JSON
 * objects into highly dense Unicode strings and decompressing them back.
 *
 *                --- PUBLIC API ---
 *
 *   compress(jsonObject)
 *     - Takes: A valid JSON object.
 *     - Returns: A highly compressed Unicode string.
 *
 *   decompress(unicodeString)
 *     - Takes: A string generated by the `compress` function.
 *     - Returns: The original, perfectly reconstructed JSON object.
 *
 * (Aliases `JSONtoString` and `stringToJSON` are also provided)
 * ====================================================================
 */

// ===================================================================================
// SECTION 1: PUBLIC API 
// ===================================================================================

/**
 * Compresses a JSON object into a dense Unicode string using a two-stage process.
 * @param {object} jsonObject The original JSON object.
 * @returns {string} The final, highly compressed Unicode string.
 */
function compress(jsonObject) {
    // Stage 1: JSON -> Compact String
    const compactString = _encodeJson(jsonObject);
    // Stage 2: Compact String -> Dense Unicode String
    const unicodeString = _encodeStringToUnicode(compactString);
    return unicodeString;
}

/**
 * Decompresses a dense Unicode string back into its original JSON object.
 * @param {string} unicodeString The compressed Unicode string.
 * @returns {object} The original, reconstructed JSON object.
 */
function decompress(unicodeString) {
    // Stage 1: Dense Unicode String -> Compact String
    const compactString = _decodeUnicodeToString(unicodeString);
    // Stage 2: Compact String -> JSON
    const jsonObject = _decodeJson(compactString);
    return jsonObject;
}

// User-requested aliases for the main functions
const JSONtoString = compress;
const stringToJSON = decompress;


// ===================================================================================
// SECTION 2: INTERNAL IMPLEMENTATION 
//
// You do not need to call these functions directly. They are used
// internally by the `compress` and `decompress` functions.
// ===================================================================================

// --- STAGE 1: JSON <-> Compact String Logic ---

function _encodeJson(originalJson) {
    const keyMapSet = new Set();

    function findKeys(obj) {
        if (obj === null || typeof obj !== 'object') return;
        if (Array.isArray(obj)) {
            obj.forEach(findKeys);
        } else {
            Object.keys(obj).forEach(key => {
                keyMapSet.add(key);
                findKeys(obj[key]);
            });
        }
    }
    findKeys(originalJson);
    const keyMap = Array.from(keyMapSet);
    const keyIndexMap = new Map(keyMap.map((key, i) => [key, i]));

    function compressData(data) {
        if (typeof data !== 'object' || data === null) {
            return data;
        }
        if (Array.isArray(data)) {
            return data.map(compressData);
        }
        const compressedObj = {};
        for (const key in data) {
            compressedObj[keyIndexMap.get(key)] = compressData(data[key]);
        }
        return compressedObj;
    }
    const compressedData = compressData(originalJson);

    const SAFE_STRING_REGEX = /^[a-zA-Z0-9_.-]+$/;
    const SPECIAL_MARKERS_AS_STRINGS = new Set(['t', 'f', 'n']);
    const DELIMITER = '|';

    function customStringify(data) {
        if (data === true) return 't';
        if (data === false) return 'f';
        if (data === null) return 'n';
        if (typeof data === 'string') {
            if (SPECIAL_MARKERS_AS_STRINGS.has(data) || data.includes(DELIMITER) || !SAFE_STRING_REGEX.test(data)) {
                return JSON.stringify(data);
            }
            return data;
        }
        if (typeof data === 'number') {
            return String(data);
        }
        if (Array.isArray(data)) {
            return `[${data.map(customStringify).join(',')}]`;
        }
        const pairs = Object.keys(data).map(key => `${key}:${customStringify(data[key])}`);
        return `{${pairs.join(',')}}`;
    }

    const schemaString = customStringify(keyMap);
    const dataString = customStringify(compressedData);
    return `${schemaString}${DELIMITER}${dataString}`;
}

function _decodeJson(compressedString) {
    const delimiterIndex = compressedString.indexOf('|');
    if (delimiterIndex === -1) {
        throw new Error("Invalid compressed string: delimiter '|' not found.");
    }
    const schemaString = compressedString.substring(0, delimiterIndex);
    const dataString = compressedString.substring(delimiterIndex + 1);

    function createParser(str) {
        const tokenizerRegex = /"((?:\\.|[^"\\])*)"|[\[\]{},:]|[\w.-]+/g;
        const tokens = str.match(tokenizerRegex);
        if (!tokens) return null;
        let tokenIndex = 0;
        return function parse() {
            const token = tokens[tokenIndex++];
            if (token.startsWith('"')) {
                return JSON.parse(token);
            }
            if (token === '{') {
                const obj = {};
                while (tokens[tokenIndex] !== '}') {
                    if (tokens[tokenIndex] === ',') tokenIndex++;
                    const key = parse();
                    tokenIndex++;
                    const value = parse();
                    obj[key] = value;
                }
                tokenIndex++;
                return obj;
            }
            if (token === '[') {
                const arr = [];
                while (tokens[tokenIndex] !== ']') {
                    if (tokens[tokenIndex] === ',') tokenIndex++;
                    arr.push(parse());
                }
                tokenIndex++;
                return arr;
            }
            if (token === 't') return true;
            if (token === 'f') return false;
            if (token === 'n') return null;
            const num = parseFloat(token);
            if (!isNaN(num) && String(num) === token) return num;
            return token;
        };
    }

    const keyMap = createParser(schemaString)();
    const data = createParser(dataString)();

    function decompressData(cData) {
        if (typeof cData !== 'object' || cData === null) {
            return cData;
        }
        if (Array.isArray(cData)) {
            return cData.map(decompressData);
        }
        const decompressedObj = {};
        for (const key in cData) {
            decompressedObj[keyMap[key]] = decompressData(cData[key]);
        }
        return decompressedObj;
    }
    return decompressData(data);
}

// --- STAGE 2: Compact String <-> Dense Unicode Logic ---

const _ENCODING_BASE = 55203;
const _ENCODING_BASE_CHAR_CODE = 93;
const _MAX_CAPACITY = _ENCODING_BASE * _ENCODING_BASE;

function _calculateTotalStrings(alphabetSize, length) {
    const size = Number(alphabetSize);
    if (size <= 0 || length <= 0) return 0;
    if (size === 1) return Number(length);
    const power = Math.pow(size, length);
    return (size * (power - 1)) / (size - 1);
}

function _findMaxPossibleLength(alphabetSize, maxCapacity) {
    if (alphabetSize <= 1) return maxCapacity;
    let low = 1,
        high = 2000,
        maxLen = 0;
    while (low <= high) {
        const mid = low + Math.floor((high - low) / 2);
        if (mid === 0) break;
        const total = _calculateTotalStrings(alphabetSize, mid);
        if (total <= maxCapacity) {
            maxLen = mid;
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return maxLen;
}

function _encodeIndexToUnicode(index) {
    const digit1 = Math.floor(index / _ENCODING_BASE);
    const digit2 = index % _ENCODING_BASE;
    const char1 = String.fromCodePoint(_ENCODING_BASE_CHAR_CODE + digit1);
    const char2 = String.fromCodePoint(_ENCODING_BASE_CHAR_CODE + digit2);
    return char1 + char2;
}

function _decodeUnicodeToIndex(payload) {
    const digit1 = payload.codePointAt(0) - _ENCODING_BASE_CHAR_CODE;
    const digit2 = payload.codePointAt(1) - _ENCODING_BASE_CHAR_CODE;
    return digit1 * _ENCODING_BASE + digit2;
}

function _createEncoderDecoder(alphabetString) {
    const alphabet = Array.from(new Set(alphabetString)).sort().join('');
    const alphabetSize = alphabet.length;
    const charMap = new Map(alphabet.split('').map((char, i) => [char, i]));
    const L_max = _findMaxPossibleLength(alphabet.length, _MAX_CAPACITY);
    const totalStrings = _calculateTotalStrings(alphabet.length, L_max);
    if (L_max === 0) {
        console.warn(`Warning: Alphabet "${alphabet}" is too large.`);
    }
    return {
        alphabet,
        alphabetSize,
        L_max,
        totalStrings,
        getStringByIndex(index) {
            index = Number(index);
            if (index < 0 || index >= this.totalStrings) throw new Error(`Index ${index} is out of bounds.`);
            let length = 1,
                baseOffset = 0;
            while (true) {
                const countForLength = Math.pow(this.alphabetSize, length);
                if (index < baseOffset + countForLength) break;
                baseOffset += countForLength;
                length++;
            }
            let positionInLengthGroup = index - baseOffset;
            let result = '';
            for (let i = length - 1; i >= 0; i--) {
                const power = Math.pow(this.alphabetSize, i);
                const charIndex = Math.floor(positionInLengthGroup / power);
                result += this.alphabet[charIndex];
                positionInLengthGroup %= power;
            }
            return result;
        },
        getIndexByString(str) {
            const len = str.length;
            if (len === 0 || len > this.L_max) throw new Error(`String "${str}" (length ${len}) is invalid.`);
            const baseOffset = (len > 1) ? _calculateTotalStrings(this.alphabetSize, len - 1) : 0;
            let positionInLengthGroup = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str[i];
                if (!charMap.has(char)) throw new Error(`Invalid character "${char}".`);
                positionInLengthGroup += charMap.get(char) * Math.pow(this.alphabetSize, str.length - 1 - i);
            }
            return baseOffset + positionInLengthGroup;
        }
    };
}

function _encodeStringToUnicode(longString) {
    const codec = _createEncoderDecoder(longString);
    const L_max = codec.L_max;
    if (L_max === 0) throw new Error("Cannot encode: The alphabet is too diverse for the given capacity.");
    const sizeCharCode = _ENCODING_BASE_CHAR_CODE + (codec.alphabet.length - 1);
    const sizeChar = String.fromCodePoint(sizeCharCode);
    const header = sizeChar + codec.alphabet;
    let unicodePayloads = "";
    for (let i = 0; i < longString.length; i += L_max) {
        const chunk = longString.substring(i, i + L_max);
        const index = codec.getIndexByString(chunk);
        unicodePayloads += _encodeIndexToUnicode(index);
    }
    return header + unicodePayloads;
}

function _decodeUnicodeToString(encodedData) {
    const sizeCharCode = encodedData.codePointAt(0);
    const alphabetLength = (sizeCharCode - _ENCODING_BASE_CHAR_CODE) + 1;
    const alphabet = encodedData.substring(1, 1 + alphabetLength);
    const fullPayload = encodedData.substring(1 + alphabetLength);
    const codec = _createEncoderDecoder(alphabet);
    let decodedString = "";
    for (let i = 0; i < fullPayload.length; i += 2) {
        const payloadChunk = fullPayload.substring(i, i + 2);
        const index = _decodeUnicodeToIndex(payloadChunk);
        decodedString += codec.getStringByIndex(index);
    }
    return decodedString;
}

// ===================================================================================
// SECTION 3: Comprehensive Test Suite
// ===================================================================================

const largeComplexJsonWithEdgeCases = {
    "sessionId": "sess_abc123xyz",
    "userProfile": {
        "userId": 98765,
        "username": "test_user",
        "isActive": true,
        "roles": ["admin", "editor"],
        "preferences": null,
        "statusMessage": "All systems are go!"
    },
    "orderHistory": [{
        "orderId": "ord_1a",
        "timestamp": 1672531200,
        "items": [{
            "productId": "p_001",
            "quantity": 2,
            "isGift": false
        }, {
            "productId": "p_002",
            "quantity": 1,
            "isGift": true
        }, {
            "productId": "t",
            "quantity": 1,
            "isGift": false
        }],
        "isShipped": true
    },
    {
        "orderId": "ord_2b",
        "timestamp": 1672617600,
        "items": [{
            "productId": "p_003",
            "quantity": 5,
            "isGift": false
        }],
        "isShipped": false,
        "notes": "Handle with care | Fragile item"
    }
    ],
    "lastLogin": {
        "timestamp": 1672704000,
        "fromIp": "192.168.1.1"
    },
    "errorCodes": ["n/a", "f-1"]
};

console.log("--- TESTING END-TO-END COMPRESSION LIBRARY ---");

// 1. Start with a JSON object
const originalJsonString = JSON.stringify(largeComplexJsonWithEdgeCases);
console.log("\n1. Original Minified JSON Size:", originalJsonString.length, "chars");

// 2. Compress it using the simple, high-level API
const finalUnicodePayload = compress(largeComplexJsonWithEdgeCases);
console.log("\n2. Final Compressed Unicode Payload Size:", finalUnicodePayload.length, "chars");
console.log("   -> Payload:", finalUnicodePayload);

// 3. Decompress it using the simple, high-level API
const fullyDecodedJson = decompress(finalUnicodePayload);
console.log("\n3. Decompression complete. Verifying data integrity...");

// 4. Verify the result
const finalDecodedJsonString = JSON.stringify(fullyDecodedJson);
const areIdentical = originalJsonString === finalDecodedJsonString;

console.log("\n--- VERIFICATION RESULT ---");
console.log("Original and Final Decoded objects are identical:", areIdentical ? "✅ YES" : "❌ NO");

if (areIdentical) {
    const overallCompression = (1 - (finalUnicodePayload.length / originalJsonString.length)) * 100;
    console.log(`\nOverall Compression Ratio: ${overallCompression.toFixed(2)}%`);
} else {
    console.error("\n\n❌❌❌ DECODING FAILED! ❌❌❌");
    console.log("\nOriginal JSON:\n", JSON.stringify(largeComplexJsonWithEdgeCases, null, 2));
    console.log("\nDecoded JSON:\n", JSON.stringify(fullyDecodedJson, null, 2));
}