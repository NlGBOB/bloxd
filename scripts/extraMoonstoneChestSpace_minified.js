function compress(t) { return _encodeStringToUnicode(_encodeJson(t)) } function decompress(t) { return _decodeJson(_decodeUnicodeToString(t)) } const JSONtoString = compress, stringToJSON = decompress; function _encodeJson(t) { const n = new Set; !function t(e) { null !== e && "object" == typeof e && (Array.isArray(e) ? e.forEach(t) : Object.keys(e).forEach((r => { n.add(r), t(e[r]) }))) }(t); const e = Array.from(n), r = new Map(e.map(((t, n) => [t, n]))); const o = function t(n) { if ("object" != typeof n || null === n) return n; if (Array.isArray(n)) return n.map(t); const e = {}; for (const o in n) e[r.get(o)] = t(n[o]); return e }(t), i = /^[a-zA-Z0-9_.-]+$/, c = new Set(["t", "f", "n"]); function s(t) { if (!0 === t) return "t"; if (!1 === t) return "f"; if (null === t) return "n"; if ("string" == typeof t) return c.has(t) || t.includes("|") || !i.test(t) ? JSON.stringify(t) : t; if ("number" == typeof t) return String(t); if (Array.isArray(t)) return `[${t.map(s).join(",")}]`; return `{${Object.keys(t).map((n => `${n}:${s(t[n])}`)).join(",")}}` } return `${s(e)}|${s(o)}` } function _decodeJson(t) { const n = t.indexOf("|"); if (-1 === n) throw new Error("Invalid compressed string: delimiter '|' not found."); const e = t.substring(0, n), r = t.substring(n + 1); function o(t) { const n = t.match(/"((?:\\.|[^"\\])*)"|[\[\]{},:]|[\w.-]+/g); if (!n) return null; let e = 0; return function t() { const r = n[e++]; if (r.startsWith('"')) return JSON.parse(r); if ("{" === r) { const r = {}; for (; "}" !== n[e];) { "," === n[e] && e++; const o = t(); e++; const i = t(); r[o] = i } return e++, r } if ("[" === r) { const r = []; for (; "]" !== n[e];)"," === n[e] && e++, r.push(t()); return e++, r } if ("t" === r) return !0; if ("f" === r) return !1; if ("n" === r) return null; const o = parseFloat(r); return isNaN(o) || String(o) !== r ? r : o } } const i = o(e)(); return function t(n) { if ("object" != typeof n || null === n) return n; if (Array.isArray(n)) return n.map(t); const e = {}; for (const r in n) e[i[r]] = t(n[r]); return e }(o(r)()) } const _ENCODING_BASE = 55203, _ENCODING_BASE_CHAR_CODE = 93, _MAX_CAPACITY = _ENCODING_BASE * _ENCODING_BASE; function _calculateTotalStrings(t, n) { const e = Number(t); if (e <= 0 || n <= 0) return 0; if (1 === e) return Number(n); return e * (Math.pow(e, n) - 1) / (e - 1) } function _findMaxPossibleLength(t, n) { if (t <= 1) return n; let e = 1, r = 2e3, o = 0; for (; e <= r;) { const i = e + Math.floor((r - e) / 2); if (0 === i) break; _calculateTotalStrings(t, i) <= n ? (o = i, e = i + 1) : r = i - 1 } return o } function _encodeIndexToUnicode(t) { const n = Math.floor(t / _ENCODING_BASE), e = t % _ENCODING_BASE; return String.fromCodePoint(_ENCODING_BASE_CHAR_CODE + n) + String.fromCodePoint(_ENCODING_BASE_CHAR_CODE + e) } function _decodeUnicodeToIndex(t) { const n = t.codePointAt(0) - _ENCODING_BASE_CHAR_CODE, e = t.codePointAt(1) - _ENCODING_BASE_CHAR_CODE; return n * _ENCODING_BASE + e } function _createEncoderDecoder(t) { const n = Array.from(new Set(t)).sort().join(""), e = n.length, r = new Map(n.split("").map(((t, n) => [t, n]))), o = _findMaxPossibleLength(n.length, _MAX_CAPACITY), i = _calculateTotalStrings(n.length, o); return 0 === o && console.warn(`Warning: Alphabet "${n}" is too large.`), { alphabet: n, alphabetSize: e, L_max: o, totalStrings: i, getStringByIndex(t) { if ((t = Number(t)) < 0 || t >= this.totalStrings) throw new Error(`Index ${t} is out of bounds.`); let n = 1, e = 0; for (; ;) { const r = Math.pow(this.alphabetSize, n); if (t < e + r) break; e += r, n++ } let r = t - e, o = ""; for (let t = n - 1; t >= 0; t--) { const n = Math.pow(this.alphabetSize, t), e = Math.floor(r / n); o += this.alphabet[e], r %= n } return o }, getIndexByString(t) { const n = t.length; if (0 === n || n > this.L_max) throw new Error(`String "${t}" (length ${n}) is invalid.`); const e = n > 1 ? _calculateTotalStrings(this.alphabetSize, n - 1) : 0; let o = 0; for (let n = 0; n < t.length; n++) { const e = t[n]; if (!r.has(e)) throw new Error(`Invalid character "${e}".`); o += r.get(e) * Math.pow(this.alphabetSize, t.length - 1 - n) } return e + o } } } function _encodeStringToUnicode(t) { const n = _createEncoderDecoder(t), e = n.L_max; if (0 === e) throw new Error("Cannot encode: The alphabet is too diverse for the given capacity."); const r = _ENCODING_BASE_CHAR_CODE + (n.alphabet.length - 1), o = String.fromCodePoint(r) + n.alphabet; let i = ""; for (let r = 0; r < t.length; r += e) { const o = t.substring(r, r + e); i += _encodeIndexToUnicode(n.getIndexByString(o)) } return o + i } function _decodeUnicodeToString(t) { const n = t.codePointAt(0) - _ENCODING_BASE_CHAR_CODE + 1, e = t.substring(1, 1 + n), r = t.substring(1 + n), o = _createEncoderDecoder(e); let i = ""; for (let t = 0; t < r.length; t += 2) { const n = _decodeUnicodeToIndex(r.substring(t, t + 2)); i += o.getStringByIndex(n) } return i }